#include <stdio.h>
#include "freertos/FreeRTOSConfig.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/i2s_std.h"
#include "esp_log.h"
#include "freertos/ringbuf.h"
#include "driver/gpio.h"
#include "sdkconfig.h"
#include "driver/i2s_common.h"
#include "driver/i2s_types.h"
#include "Biquad.h"

#define I2S_NUM         I2S_NUM_0
#define SAMPLE_RATE     44100
#define I2S_PIN_BCLK     26  // BCLK
#define I2S_PIN_WS       25  // WS
#define I2S_PIN_DIN      22  // DIN вход
#define I2S_PIN_DOUT     19  // DOUT изход


// Размер на DMA буферите и RingBuffer
#define RINGBUF_SIZE 512     // Размер на RingBuffer в байтове (множество на 3 за 24 бита)


// RingBuffer
RingbufHandle_t rx_ringbuffer = NULL;
//i2s_chan_handle_t rx_handle = NULL, tx_handle = NULL;
i2s_chan_handle_t rx_chan = NULL, tx_chan = NULL;
// Таг за логовете
#define TAG "I2S_STD"

// Функция за инициализация на I2S с новия API
void init_i2s(void) {
	  // Конфигурация на I2S канала в SLAVE режим
    
    
    // Създаване на RingBuffer за съхранение на данни (трябва да е кратно на 3 за 24 бита)
    rx_ringbuffer = xRingbufferCreate(RINGBUF_SIZE, RINGBUF_TYPE_BYTEBUF);
    if (rx_ringbuffer == NULL) {
        ESP_LOGE(TAG, "Неуспешно създаване на RingBuffer!");
        return;
    }

    // Конфигурация за I2S канала
	 i2s_chan_config_t chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_SLAVE);
	// chan_cfg.auto_clear = true;

    ESP_ERROR_CHECK(i2s_new_channel(&chan_cfg, &tx_chan, &rx_chan));

    /* Step 2: Setting the configurations of standard mode, and initialize rx & tx channels
     * The slot configuration and clock configuration can be generated by the macros
     * These two helper macros is defined in 'i2s_std.h' which can only be used in STD mode.
     * They can help to specify the slot and clock configurations for initialization or re-configuring */
    i2s_std_config_t std_cfg = {
        .clk_cfg  = I2S_STD_CLK_DEFAULT_CONFIG(44100),
        .slot_cfg = I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_32BIT, I2S_SLOT_MODE_STEREO),
        .gpio_cfg = {
            .mclk = -1,    // some codecs may require mclk signal, this example doesn't need it
            .bclk = I2S_PIN_BCLK,
            .ws   = I2S_PIN_WS,
            .dout = I2S_PIN_DOUT,
            .din  = I2S_PIN_DIN, // In duplex mode, bind output and input to a same gpio can loopback internally
            .invert_flags = {
                .mclk_inv = false,
                .bclk_inv = false,
                .ws_inv   = false,
            },
        },
    };
     /* Set data bit-width to 24 means your sample is 24 bits, I2S will help to shift the data by hardware */
    //std_cfg.slot_cfg.data_bit_width = I2S_DATA_BIT_WIDTH_24BIT;
    /* Set slot bit-width to 32 means there still will be 32 bit in one slot */
   // std_cfg.slot_cfg.slot_bit_width = I2S_SLOT_BIT_WIDTH_32BIT;
    std_cfg.clk_cfg.clk_src = I2S_CLK_SRC_APLL;
    //std_cfg.clk_cfg.mclk_multiple = 384;
    //std_cfg .slot_cfg.left_align = true;
    
    /* Initialize the channels */
    ESP_ERROR_CHECK(i2s_channel_init_std_mode(tx_chan, &std_cfg));
    ESP_ERROR_CHECK(i2s_channel_enable(tx_chan));
    
    ESP_ERROR_CHECK(i2s_channel_init_std_mode(rx_chan, &std_cfg));
    ESP_ERROR_CHECK(i2s_channel_enable(rx_chan));

}
/*
void process_data_stereo(int32_t *data, size_t num_samples) {
    for (size_t i = 0; i < num_samples; i += 2) {
        // Ляв канал
        data[i] = data[i] * 0.9;  // Намаляване на амплитудата с 10%

        // Десен канал
        data[i + 1] = data[i + 1] * 0.9;  // Намаляване на амплитудата с 10%
    }
}
*/
void app_main(void) {
	init_i2s();
        create_biquad();
     // Буфер за четене
    int32_t *data = (int32_t *)malloc(RINGBUF_SIZE);

    size_t bytes_read;
    size_t bytes_written;

    // Основен цикъл
    
    while (1) {
        // Четене на данни от I2S (DIR9001)
        esp_err_t ret = i2s_channel_read(rx_chan, data, RINGBUF_SIZE, &bytes_read, portMAX_DELAY);
        if (ret == ESP_OK) {
          //  ESP_LOGI(TAG, "Прочетени %d байта от DIR9001", bytes_read);

        } else {
            ESP_LOGW(TAG, "Неуспешно четене от I2S");
        }
		
			process_data_stereo(data, bytes_read / sizeof(int32_t));
            // Писане на данни в I2S (към TDA1387)
            esp_err_t write_ret = i2s_channel_write(tx_chan, data, RINGBUF_SIZE, &bytes_read, portMAX_DELAY);
            

            // Освобождаване на паметта от RingBuffer
     //       vRingbufferReturnItem(rx_ringbuffer, received_data);
   //     } else {
     //       ESP_LOGW(TAG, "Неуспешно извличане на данни от RingBuffer");
       // }
    }
}